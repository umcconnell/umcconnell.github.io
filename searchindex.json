{
    "index": [
        {
            "title": "Stars and Bars",
            "url": "/posts/2024-08-25-stars-bars/",
            "updated": "2024-08-25T00:00:00Z",
            "description": "A short and useful theorem in combinatorics.",
            "content": "How many ways are there to distribute nnn undistinguishable items into kkk bins? Consider the following illustration for the situation where we distribute 777 items (stars) into 4 bins (intervals between bars) indicated by separators: ⋆ ⋆ | ⋆ ⋆ | | ⋆ ⋆ ⋆ &#92;star~&#92;star~&#92;text{&#92;textbar}~&#92;star~&#92;star~&#92;text{&#92;textbar}~&#92;text{&#92;textbar}~&#92;star~&#92;star~~&#92;star ⋆ ⋆ | ⋆ ⋆ | | ⋆ ⋆ ⋆ We see that the problem is equivalent to choosing k−1k-1k−1 out of the overall n+k−1n + k - 1n+k−1 positions for separators (bars) before placing nnn items (stars) in the remaining slots. This leads to the following conclusion: Lemma (Stars and Bars) Let n,k∈Nn, k &#92;in &#92;mathbb{N}n,k∈N with k≥1k &#92;geq 1k≥1. The number of ways to place nnn undistinguishable items into kkk bins is given by (n+k−1k−1)(1)&#92;tag{1} &#92;binom{n + k - 1}{k - 1} (k−1n+k−1​)(1) Equivalently, eq. (1) gives the number of non-negative integer solutions to the following equation where xi∈Nx_i &#92;in &#92;mathbb{N}xi​∈N for 1≤i≤k1 &#92;leq i &#92;leq k1≤i≤k: x1+⋯+xk=nx_1 + &#92;dots + x_k = n x1​+⋯+xk​=n Example Let’s consider the following example problem, where n,k∈Nn, k &#92;in &#92;mathbb{N}n,k∈N with n≥kn &#92;geq kn≥k: How many different ways are there to select exactly kkk elements from {1,…,n}&#92;{1, &#92;dots, n&#92;}{1,…,n} such that the sum of these elements is at most n? This problem can be reformulated as follows: How many solutions does the inequality x1+⋯+xk≤nx_1 + &#92;dots + x_k &#92;leq nx1​+⋯+xk​≤n permit for natural numbers xi≥1x_i &#92;geq 1xi​≥1? We can rewrite the inequality to use non-negative integer variables yiy_iyi​ by adding 111 to every variable, as well as adding a dummy term yk+1y_{k+1}yk+1​ representing the (non-negative) difference between the right- and left-hand side to obtain an equality: (y1+1)+⋯+(yk+1)≤n ⟺ y1+⋯+yk+yk+1=n−k&#92;begin{aligned} (y_1 + 1) &amp;amp;+ &#92;dots + (y_k + 1) &amp;amp;&amp;amp;&#92;leq n &#92;&#92; &#92;iff y_1 &amp;amp;+ &#92;dots + y_k + y_{k+1} &amp;amp;&amp;amp;= n - k &#92;end{aligned} (y1​+1)⟺y1​​+⋯+(yk​+1)+⋯+yk​+yk+1​​​≤n=n−k​ By the Stars and Bars lemma (1), this problem has ((n−k)+(k+1)−1(k+1)−1)=(nk) &#92;binom{(n - k) + (k + 1) - 1}{(k + 1) - 1} = &#92;binom{n}{k} ((k+1)−1(n−k)+(k+1)−1​)=(kn​) solutions.",
            "id": "https://www.umcconnell.net/posts/2024-08-25-stars-bars/",
            "tags": ["posts", "math", "combinatorics"]
        },
        {
            "title": "Podcast Synchronization Over the Cloud",
            "url": "/posts/2024-08-23-opodsync/",
            "updated": "2024-08-23T00:00:00Z",
            "description": "Setting up a podcast synchronization service on Google Cloud.",
            "content": "As a regular and avid podcast listener, I was looking for a solution to synchronize my subscriptions and episode status across several devices. On mobile, I use the excellent Antenna Pod app, while on desktop I rely on gPodder . Since the open-source synchronization server gPodder.net frequently encounters status 500 errors, I decided to set up my own synchronization server using the lightweight, gPodder-compatible opodsync . In this guide, I will describe how to set up opodsync on Google Cloud. Before starting, ensure you have a Google Cloud account and a domain name through which the synchronization server will be accessible. Server To get started, create a new virtual machine (VM) from the cloud dashboard. This option is also accessible through the resources tab or in the sidebar under “Compute Engine”. I used the small e2-micro instance which is sufficient for this task, and also has the advantage of being part of the free tier. As of this writing, the following configuration options are part of the free tier: Configuration Region: us-central1 Machine Configuration: E2 Machine Type: e2-micro (2 vCPU, 1 Core, 1 GB memory) Availability policies: Standard Boot disk: 30 GB standard persistent disk, Debian (click “change” to adjust operating system &amp;amp; more) Network service tier: Standard Firewall: Allow HTTP &amp;amp; HTTPS traffic Configuring the boot disk More details and up-to-date configuration options can be found in the docs: https://cloud.google.com/free/docs/free-cloud-features#compute . Note that a monthly estimate of costs (around 7 USD for the above configuration) will be shown, even if your selection is covered by the free tier. Once the VM is created, connect to it through SSH to install the synchronization server. The easiest way to connect is through the web interface, which opens a terminal directly in your browser. To do this, go to the VM instance overview (found under “Compute Engine” in the sidebar) and click “SSH”. As a first step, install the Apache server: sudo apt update &amp;amp;&amp;amp; sudo apt -y install apache2 Check that Apache is running: sudo systemctl status apache2 At this point you can check that the server is reachable online. In the VM instances overview, copy the external IP. You should see the Apache default page when navigating to http://YOUR.EXTERNAL.IP.ADDRESS. Important: Make sure you are not trying to connect through HTTPS (this may be the default when clicking on the link), as HTTPS will be set up later. Opodsync Next, install php7.4 and a few other required dependencies: sudo apt update &amp;amp;&amp;amp; sudo apt -y install unzip sudo apt install -y apt-transport-https lsb-release ca-certificates wget sudo wget -O /etc/apt/trusted.gpg.d/php.gpg https://packages.sury.org/php/apt.gpg echo &quot;deb https://packages.sury.org/php/ $(lsb_release -sc) main&quot; | sudo tee /etc/apt/sources.list.d/php.list sudo apt install -y php7.4 php7.4-sqlite3 libapache2-mod-php7.4 Download the actual code and move it to /var/www/html, which is the default directory for Apache: wget https://github.com/kd2org/opodsync/archive/refs/heads/main.zip unzip main.zip -d opodsync sudo rm /var/www/html/index.html sudo mv opodsync/opodsync-main/server/* /var/www/html/ sudo chown -R www-data:www-data /var/www/html sudo chmod -R 755 /var/www/html You can also add custom configurations in /var/www/html/data/config.local.php, such as a different title. A configuration template and more detailed instructions can be found on the opodsync Github: https://github.com/kd2org/opodsync/blob/main/README.md#configuration We will now configure the Apache server. In /etc/apache2/sites-available/ create the file opodsync.conf with the following content: &amp;lt;VirtualHost &#92;*:80&gt; ServerName YOUR.CUSTOM.DOMAIN ServerAdmin webmaster@localhost DocumentRoot /var/www/html &amp;lt;Directory /var/www/html&gt; AllowOverride All &amp;lt;/Directory&gt; ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined &amp;lt;/VirtualHost&gt; Replace YOUR.CUSTOM.DOMAIN with the domain name that will be configured below in the DNS section. In /var/www/html/ create the file .htaccess with the following content: # Make sure Authorization header is transmitted to PHP SetEnvIf Authorization .+ HTTP_AUTHORIZATION=$0 RedirectMatch 404 inc/.* RedirectMatch 404 data/.* FallbackResource /index.php Finally, enable the new configuration and restart the server: sudo a2ensite opodsync.conf sudo service apache2 restart You should now be able to access the landing page, although redirects to the login and register pages won’t work until the custom domain is set up. DNS Before setting up HTTPS, make sure you can access the site through the chosen domain name. Add an A record pointing to the public IP address of your VM. This should match the ServerName in the Apache server configuration. Once everything is set up, you should be able to access the server through your domain name and also access the login/register page. TLS Setting up HTTPS is straightforward using Let’s Encrypt . Just install certbot and follow the instructions. Cerbot will automatically configure the Apache server to properly redirect to HTTPS: sudo apt-get install certbot python3-certbot-apache sudo certbot --apache Once this is done, restart the server: sudo service apache2 restart You should now be able to register your first user through the web interface. By default, opodsync will block further user registration, but this can be changed in the settings. Podcast apps The last step is to set up your podcast apps. In AntennaPod, navigate to Settings &amp;gt; Synchronization and use the custom domain name and your user credentials to log in. For gPodder, this option is available through Preferences &amp;gt; gpodder.net. Note that for gPodder you must use the “gPodder secret username” that is displayed when logging in to opodsync. Happy synchronizing!",
            "id": "https://www.umcconnell.net/posts/2024-08-23-opodsync/",
            "tags": ["posts", "dev", "cloud"]
        },
        {
            "title": "Dirac&#39;s theorem on Hamiltonian Graphs",
            "url": "/posts/2024-07-31-dirac-theorem-hamiltonian/",
            "updated": "2024-07-31T00:00:00Z",
            "description": "Three different proofs of Dirac&#39;s theorem on Hamiltonian cycles in graphs with sufficient minimum degree.",
            "content": "Overview &amp;amp; Background Continuing the theme of last post, we will look at a classic result in graph theory, namely Dirac’s theorem on Hamiltonian cycles. This result was first published by Gabriel A. Dirac in 1952 [1], with later refinements by Ore, as well as Bondy and Chvátal. Three proofs of the theorem will be presented: the original proof from Dirac’s paper, an induction proof, and a short and direct proof. We will also consider the tightness of the bound as well as a generalization by Ore. As a little historical sidenote before diving into the mathematics, Gabriel Dirac was the son of Margit Wigner, the sister of famous physicist Eugene Wigner. After a first marriage, from which Gabriel was born, Margit later remarried Eugene Wigner’s friend Paul Dirac, another equally famous physicist and one of the founders of Quantum Mechanics. Subsequently, Gabriel chose to take on the name Dirac. More interesting biographical details can be found in the essay about Paul Dirac on MacTutor. Table of contents Overview &amp;amp; BackgroundDirac’s theoremConnectednessOriginal proofDouble inductionInduction IInduction IIConclusionDirect proofTightnessOre’s theoremFurther readingOverview of notation Dirac’s theorem Although the following definitions are standard in graph theory, it is useful to specify them at the outset as these terms are often used rather loosely. A path is a sequence of non-repeating vertices and edges, where subsequent vertices are connected by an edge in the graph. Usually we distinguish between open and closed paths, where as the name implies, an open path just has different start and end vertices, while a closed path starts and ends with the same vertex. A closed path is also called a cycle. The length of a cycle is the number of distinct vertices on the cycle (the equal start- and end-vertex is not counted twice). As always, I will try to stick to common graph theoretical notation and conventions, but for the sake of both readability and completeness an overview of notation is given at the end of the post. A Hamiltonian cycle is a cycle through a graph that visits every vertex exactly once. This concept might sound similar to Euler tours, that are historically at the origin of graph theory. An Euler tour is a cycle that visits every edge exactly once, while repeated vertices are allowed. However, in contrast to Euler tours which can be found in a graph in linear time O(∣V∣+∣E∣)&#92;mathcal{O}(|V|+|E|)O(∣V∣+∣E∣), finding and even checking whether a graph contains a Hamiltonian cycle is in general NP&#92;mathcal{NP}NP-complete, i.e. no known polynomial time exists for this problem. Finding a Hamiltonian cycle and the related optimization problem of finding a lowest weight Hamiltonian cycle (known as the travelling salesperson problem ) has many applications from computer graphics and circuit design to cargo routing and bioinformatics. We will consider Dirac’s theorem, which is a sufficient condition for graphs to contain a Hamiltonian cycle: Theorem (Dirac, 1952) Let G=(V,E)G = (V, E)G=(V,E) be a graph with ∣V∣≥3|V| &#92;geq 3∣V∣≥3 and minimum degree δ(G)≥∣V∣2&#92;delta(G) &#92;geq &#92;frac{|V|}{2}δ(G)≥2∣V∣​ on every vertex. Then GGG contains a Hamiltonian cycle. Equivalently, every graph with minimum degree δ(G)=d&#92;delta(G) = dδ(G)=d and at most ∣V∣≤2d|V| &#92;leq 2d∣V∣≤2d vertices contains a Hamiltonian cycle. Notice that the conditions of this theorem are not necessary for a Hamiltonian cycle, as for example a cycle graph CnC_nCn​ on nnn vertices violates the degree condition but clearly contains a Hamiltonian cycle. Connectedness As a warm-up we’ll start by showing that such a “Dirac-graph” is connected, ie. GGG contains a path between any two vertices. In his original paper, Dirac writes in the theorem formulation that the graph must be connected, but as we will see now, this is not strictly necessary. Every graph that obeys the degree condition must also be connected. In fact, we will see that any two vertices are connected by a path of length at most two, where the length of a path is defined as the number of edges along that path. Consider two arbitrary vertices u,v∈Vu, v &#92;in Vu,v∈V. Without loss of generality we may assume that {u,v}∉E&#92;{u, v&#92;} &#92;not &#92;in E{u,v}∈E, as otherwise we would be done. We therefore know that the neighborhoods N(u),N(v)&#92;mathcal{N}(u), &#92;mathcal{N}(v)N(u),N(v) of uuu and vvv respectively do not contain the other vertex. But by the assumption on the minimum degree in GGG we also know that N(u)≥∣V∣2&#92;mathcal{N}(u) &#92;geq &#92;frac{|V|}{2}N(u)≥2∣V∣​ as well as N(v)≥∣V∣2&#92;mathcal{N}(v) &#92;geq &#92;frac{|V|}{2}N(v)≥2∣V∣​. We can now apply the pigeonhole principle to conclude that uuu and vvv must have a neighbor in common, and are therefore connected by a path of length 222: Both neighborhoods do not contain uuu and vvv by the previous observation, so we are trying to distribute two neighborhoods of size at least ∣V∣2&#92;frac{|V|}{2}2∣V∣​ onto ∣V∣−2|V| - 2∣V∣−2 vertices. The two must necessarily intersect. Alternatively, this same fact can be seen by applying the inclusion-exclusion principle: ∣N(u)∩N(v)∣=∣N(u)∣⏟≥∣V∣2+∣N(v)∣⏟≥∣V∣2−∣N(u)∪N(v)∣⏟≤∣V∖{u,v}∣=∣V∣−2≥2 |&#92;mathcal{N}(u) &#92;cap &#92;mathcal{N}(v)| = &#92;underbrace{|&#92;mathcal{N}(u)|}_{&#92;geq &#92;frac{|V|}{2}} + &#92;underbrace{|&#92;mathcal{N}(v)|}_{&#92;geq &#92;frac{|V|}{2}} - &#92;underbrace{|&#92;mathcal{N}(u) &#92;cup &#92;mathcal{N}(v)|}_{&#92;leq |V &#92;setminus &#92;{u, v&#92;}| = |V| - 2} &#92;geq 2 ∣N(u)∩N(v)∣=≥2∣V∣​∣N(u)∣​​+≥2∣V∣​∣N(v)∣​​−≤∣V∖{u,v}∣=∣V∣−2∣N(u)∪N(v)∣​​≥2 We can already start seeing, why this theorem is tight. Relaxing the degree constraint on the vertices would for example allow a graph G′G&amp;#x27;G′ that is the disjoint union of two complete subgaphs on half of the vertices: for X=K∣V∣2X = K_{&#92;frac{|V|}{2}}X=K2∣V∣​​ and Y=K∣V∣2Y = K_{&#92;frac{|V|}{2}}Y=K2∣V∣​​ (ignoring odd ∣V∣|V|∣V∣ for simplicity here) we could construct G′=X⊎YG&amp;#x27; = X &#92;uplus YG′=X⊎Y with a minimum degree of δ(G′)=∣V∣2−1&#92;delta(G&amp;#x27;) = &#92;frac{|V|}{2} - 1δ(G′)=2∣V∣​−1 for every vertex. This graph clearly does not contain a Hamiltionian cycle In the following three proofs, we will always assume that GGG is a graph as described in the theorem, i.e. G=(V,E)G = (V, E)G=(V,E) with δ(G)≥∣V∣2&#92;delta(G) &#92;geq &#92;frac{|V|}{2}δ(G)≥2∣V∣​. Original proof Dirac’s original proof [1:1] is a little more convoluted, but we will consider it for completeness. It contains a few unnecessary convolutions, such as two nested proofs by contradiction, that hide the essence of the argument. Feel free to skip to the next section if you are not interested in the exact technical details of the original paper. We will start by showing the following lemma: Lemma 1 Let G=(V,E)G = (V, E)G=(V,E) be a graph as defined in Dirac’s theorem. Then GGG contains a cycle of length at least δ(G)+1&#92;delta(G) + 1δ(G)+1. A longest path P=v1,…,vkP = v_1, &#92;dots, v_kP=v1​,…,vk​ in GGG must contain at least ∣V∣2+1&#92;frac{|V|}{2} + 12∣V∣​+1 vertices, because v1v_1v1​ has at least δ(G)=∣V∣2&#92;delta(G) = &#92;frac{|V|}{2}δ(G)=2∣V∣​ neighbors. Otherwise v1v_1v1​ would have a neighbor outside of PPP that we could use to extend PPP. Therefore, all neighbors of v1v_1v1​ must lie on PPP, which immediately yields a cycle of length at least δ(G)+1&#92;delta(G) + 1δ(G)+1: v1,…,vi,v1v_1, &#92;dots, v_i, v_1v1​,…,vi​,v1​ where i≥δ(G)+1i &#92;geq &#92;delta(G) + 1i≥δ(G)+1 is the highest index of neighbors of v1v_1v1​ along PPP. Now assume for sake of contradiction that the theorem is false, i.e. there exists a graph G=(V,E)G = (V, E)G=(V,E) satisfying ∣V∣≥3|V| &#92;geq 3∣V∣≥3 and δ(G)≥∣V∣2&#92;delta(G) &#92;geq &#92;frac{|V|}{2}δ(G)≥2∣V∣​ on every vertex that does not contain a Hamiltonian cycle. Let C=v1,…,vkC = v_1, &#92;dots, v_kC=v1​,…,vk​ be the longest cycle in GGG. By our assumption, CCC has length at most ∣V∣−1|V| - 1∣V∣−1. From the lemma it also follows that the cycle CCC must have length at least ∣V∣2+1&#92;frac{|V|}{2} + 12∣V∣​+1. As GGG is connected, some node in CCC, let’s assume without loss of generality that it is vkv_kvk​, must be connected to some node vk+1v_{k+1}vk+1​ in V∖CV &#92;setminus CV∖C. We will now consider the longest path P′=vk,vk+1,…,vk+lP&amp;#x27; = v_{k}, v_{k+1}, &#92;dots, v_{k + l}P′=vk​,vk+1​,…,vk+l​ that is entirely contained in V∖CV &#92;setminus CV∖C except for vkv_kvk​. By the same observation as in the proof for the lemma, vk+lv_{k + l}vk+l​ can only be connected to v1,…,vk,…,vk+l−1v_1, &#92;dots, v_k, &#92;dots, v_{k + l - 1}v1​,…,vk​,…,vk+l−1​. Under these assumptions made for sake of contradiction, the following lemma holds: Lemma 2 Under the assumption that Dirac’s theorem is false, it holds that l≥∣V∣2l &#92;geq &#92;frac{|V|}{2}l≥2∣V∣​. We will show this lemma again by contradiction. If l≤∣V∣2−1&amp;lt;∣V∣2l &#92;leq &#92;frac{|V|}{2} - 1 &amp;lt; &#92;frac{|V|}{2}l≤2∣V∣​−1&amp;lt;2∣V∣​, then vk+lv_{k+l}vk+l​ must be connected to at least δ(G)−l≥∣V∣2−l≥1&#92;delta(G) - l &#92;geq &#92;frac{|V|}{2} - l &#92;geq 1δ(G)−l≥2∣V∣​−l≥1 vertices in v1,…,vk−1v_1, &#92;dots, v_{k-1}v1​,…,vk−1​, excluding vertices vk,…,vk+l−1v_k, &#92;dots, v_{k+l-1}vk​,…,vk+l−1​ in P′P&amp;#x27;P′. So vk+lv_{k + l}vk+l​ must be connected to another vertex vi∈Cv_i &#92;in Cvi​∈C with vi≠vkv_i &#92;not = v_kvi​=vk​. We can estable the following two inequalities on iii: i≥l+1i &#92;geq l + 1i≥l+1: We can form a new cycle C′=vk+l,vi,…,vk,…,vk+lC&amp;#x27; = v_{k + l}, v_i, &#92;dots, v_k, &#92;dots, v_{k + l}C′=vk+l​,vi​,…,vk​,…,vk+l​ of length k+l−i+1k + l - i + 1k+l−i+1. Because CCC is the longest cycle in GGG, we obtain k+l−i+1≤k ⟺ i≥l+1k + l - i + 1 &#92;leq k &#92;iff i &#92;geq l + 1k+l−i+1≤k⟺i≥l+1 i≤k−l−1i &#92;leq k - l - 1i≤k−l−1: We could also form a new cycle C′′=v1,…,vi,vk+l,…,vk,v1C&amp;#x27;&amp;#x27; = v_1, &#92;dots, v_i, v_{k + l}, &#92;dots, v_k, v_1C′′=v1​,…,vi​,vk+l​,…,vk​,v1​ of length i+l+1i + l + 1i+l+1. Just as before we obtain i+l+1≤k ⟺ i≤k−l−1i + l + 1 &#92;leq k &#92;iff i &#92;leq k - l - 1i+l+1≤k⟺i≤k−l−1. By the two inequalities, we conclude that vk+lv_{k + l}vk+l​ is connected to at least ∣V∣2−l≥1&#92;frac{|V|}{2} - l &#92;geq 12∣V∣​−l≥1 vertices in I=vl+1,…,vk−l−1I = v_{l + 1}, &#92;dots, v_{k - l - 1}I=vl+1​,…,vk−l−1​. Notice that there are ∣I∣=k−2l−1|I| = k - 2l - 1∣I∣=k−2l−1 such vertices. However, it is also not possible that vk+lv_{k + l}vk+l​ is joined to two neighboring vertices viv_ivi​ and vi+1v_{i + 1}vi+1​ in III, as this would contradict the maximality of the original cycle CCC. Otherwise CCC could have been extended to v1,…,vi,vk+l,vi+1,…,vk,v1v_1, &#92;dots, v_i, v_{k + l}, v_{i + 1}, &#92;dots, v_k, v_1v1​,…,vi​,vk+l​,vi+1​,…,vk​,v1​ of length k+1k + 1k+1. By this observation, there must therefore be at least 2(∣V∣2−l)−12 &#92;left(&#92;frac{|V|}{2} - l&#92;right) - 12(2∣V∣​−l)−1 such vertices in III in order to intersperse every neighboring vertex of vk+lv_{k + l}vk+l​ with a non-neighbor. Putting all these inequalities together, we finally obtain: ∣I∣=k−2l−1&amp;gt;2(∣V∣2−l)−1 ⟺ k≥∣V∣ |I| = k - 2l - 1 &amp;gt; 2 &#92;left(&#92;frac{|V|}{2} - l&#92;right) - 1 &#92;iff k &#92;geq |V| ∣I∣=k−2l−1&amp;gt;2(2∣V∣​−l)−1⟺k≥∣V∣ But this cannot be, as we assumed that CCC is not a Hamiltonian cycle. This proves lemma 2. Proving Dirac’s theorem is now fairly straightforward, by completing the outer proof by contradiction. As we have already observed previously, CCC has length at least ∣V∣2+1&#92;frac{|V|}{2} + 12∣V∣​+1 by lemma 1. Because GGG is composed of at least CCC and P′P&amp;#x27;P′, both distinct from each other by construction, we can apply our bound on ∣P′∣|P&amp;#x27;|∣P′∣ from lemma 2: ∣V∣≥∣C∣+∣P′∣≥∣V∣2+1+∣V∣2≥∣V∣+1 |V| &#92;geq |C| + |P&amp;#x27;| &#92;geq &#92;frac{|V|}{2} + 1 + &#92;frac{|V|}{2} &#92;geq |V| + 1 ∣V∣≥∣C∣+∣P′∣≥2∣V∣​+1+2∣V∣​≥∣V∣+1 This contradiction concludes the proof. Double induction As a first proof of Dirac’s theorem, we will consider a proof by induction. This uses the so-called rotation-extension technique by Pósa[2]. Personally, I find this proof to be the most elegant of the three, especially because of the neat double induction that is used. The general structure of the proof consists of two parts: A kkk-cycle implies the existence of a k+1k+1k+1-path, as GGG is connected A kkk-path implies the existence of a k+1k+1k+1-path or a kkk cycle. By induction GGG thus has an ∣V∣|V|∣V∣-cycle, i.e. a Hamiltonian cycle. Recall that we already saw previously, that G is connected. This fact will be needed in the induction proof. Induction I For k&amp;lt;∣V∣k &amp;lt; |V|k&amp;lt;∣V∣, a kkk-cycle implies the existence of a k+1k+1k+1-path. Let C=v1,…,vk,v1C = v_1, &#92;dots, v_k, v_1C=v1​,…,vk​,v1​ be such a cycle in GGG. Because GGG is connected, there exists an edge e=(w,vi)e = (w, v_i)e=(w,vi​) from V∖{v1,…,vk}V &#92;setminus &#92;{v_1, &#92;dots, v_k&#92;}V∖{v1​,…,vk​} to CCC, where www is a vertex outside of the cycle. Without loss of generality we may assume that vi=v1v_i = v_1vi​=v1​. We have found a k+1k+1k+1-path w→v1→⋯→vkw &#92;rightarrow v_1 &#92;rightarrow &#92;dots &#92;rightarrow v_kw→v1​→⋯→vk​. Induction II A kkk-path implies the existence of a k+1k+1k+1-path or a kkk-cycle. Let P=v1,…,vkP = v_1, &#92;dots, v_kP=v1​,…,vk​ be such a path in GGG. Case N(v1)⊈{v2,…,vk}&#92;mathcal{N}(v_1) &#92;not &#92;subseteq &#92;{v_2, &#92;dots, v_k&#92;}N(v1​)⊆{v2​,…,vk​}: PPP can be extended to a k+1k+1k+1-path w→v1→⋯→vkw &#92;rightarrow v_1 &#92;rightarrow &#92;dots &#92;rightarrow v_kw→v1​→⋯→vk​, where www is a neighbor of v1v_1v1​ not in PPP. Case N(vk)⊈{v1,…,vk−1}&#92;mathcal{N}(v_k) &#92;not &#92;subseteq &#92;{v_1, &#92;dots, v_{k-1}&#92;}N(vk​)⊆{v1​,…,vk−1​}: same as above Case N(v1)⊆{v2,…,vk}&#92;mathcal{N}(v_1) &#92;subseteq &#92;{v_2, &#92;dots, v_k&#92;}N(v1​)⊆{v2​,…,vk​} and N(vk)⊆{v1,…,vk−1}&#92;mathcal{N}(v_k) &#92;subseteq &#92;{v_1, &#92;dots, v_{k-1}&#92;}N(vk​)⊆{v1​,…,vk−1​}: Let the extended neighborhood N+(vk):={vi+1 ∣ vi∈N(vk)}&#92;mathcal{N}^+(v_k) := &#92;{ v_{i+1} &#92;;&#92;vert&#92;; v_i &#92;in &#92;mathcal{N}(v_k)&#92;}N+(vk​):={vi+1​∣vi​∈N(vk​)} be the set of successors of neighbors on the path. Note that by assumption, all neighbors (and their successors) of vkv_kvk​ lie on PPP. By applying the inclusion-exclusion principle again we obtain: #katex-list-floating-image-wrapper span.katex-display { width: clamp(35rem, 35rem, 100%); } ∣N(v1)∩N+(vk)∣=∣N(v1)∣⏟≥∣V∣/2+∣N+(vk)∣⏟≥∣V∣/2−∣N(v1)∪N+(vk)∣⏟⊆V∖{v1} ⟹ ≤∣V∣−1≥1|&#92;mathcal{N}(v_1) &#92;cap &#92;mathcal{N}^+(v_k)| = &#92;underbrace{|&#92;mathcal{N}(v_1)|}_{&#92;geq |V|/2} + &#92;underbrace{|&#92;mathcal{N}^+(v_k)|}_{&#92;geq |V|/2} - &#92;underbrace{|&#92;mathcal{N}(v_1) &#92;cup &#92;mathcal{N}^+(v_k)|}_ {&#92;subseteq V&#92;setminus&#92;{v_1&#92;} &#92;implies &#92;leq |V| - 1} &#92;geq 1 ∣N(v1​)∩N+(vk​)∣=≥∣V∣/2∣N(v1​)∣​​+≥∣V∣/2∣N+(vk​)∣​​−⊆V∖{v1​}⟹≤∣V∣−1∣N(v1​)∪N+(vk​)∣​​≥1 This implies that there exists a viv_ivi​ in N(v1)∩N+(vk)&#92;mathcal{N}(v_1) &#92;cap &#92;mathcal{N}^+(v_k)N(v1​)∩N+(vk​). We have found a kkk-cycle v1→⋯→vi→vk→⋯→vi+1→v1v_1 &#92;rightarrow &#92;dots &#92;rightarrow v_i &#92;rightarrow v_k &#92;rightarrow &#92;dots &#92;rightarrow v_{i+1} &#92;rightarrow v_{1}v1​→⋯→vi​→vk​→⋯→vi+1​→v1​ Conclusion By combining both parts of the induction, we conclude that there must exist an nnn-path, and by Induction II, an ∣V∣|V|∣V∣-cycle, i.e. a Hamiltonian cycle in GGG, as GGG cannot contain an ∣V∣+1|V|+1∣V∣+1 path (paths have distinct vertices). Direct proof This is the shortest of the three proofs that will be presented, and is conceptually very similar to the induction proof. It can be found in standard textbooks on graph theory, such as the one by Diestel [3]. We will first inspect a longest path in GGG and show that it can be extended to a cycle. We will then prove that this cycle must actually be a Hamiltonian cycle. Consider a longest path P=v1,…,vkP = v_1, &#92;dots, v_kP=v1​,…,vk​ in GGG. All edges of v1v_1v1​ and vkv_kvk​ must end in PPP, as otherwise we could extend PPP, contradicting the fact that PPP is a longest path. By the same argument as in case 3 of Induction II, we can find an edge vivi+1v_i v_{i+1}vi​vi+1​ in the path, where also both {v1,vi+1}∈E&#92;{v_1, v_{i+1}&#92;} &#92;in E{v1​,vi+1​}∈E and {vi,vk}∈E&#92;{v_i, v_k&#92;} &#92;in E{vi​,vk​}∈E. We can then turn PPP into a cycle C=v1,vi+1,…,vk,vi,…,v1C = v_1, v_{i+1}, &#92;dots, v_k, v_i, &#92;dots, v_1C=v1​,vi+1​,…,vk​,vi​,…,v1​. Finally, assume for sake of contradiction that CCC is not a Hamiltonian cycle. Then there must exist at least one vertex in V∖CV &#92;setminus CV∖C. However, as GGG is connected, there must also exist an edge {u,vi}&#92;{u, v_i&#92;}{u,vi​} for u∈V∖Cu &#92;in V &#92;setminus Cu∈V∖C and vi∈Cv_i &#92;in Cvi​∈C, where we can assume vi=v1v_i = v_1vi​=v1​ without loss of generality. This is a contradiction to our initial assumption that PPP is a longest path in GGG, as u,v1,…,vku, v_1, &#92;dots, v_ku,v1​,…,vk​ would form a longer path. Tightness We will use the second equivalent formulation of Dirac’s theorem, that bounds the number of vertices as a function of the minimum degree d=δ(G)d = &#92;delta(G)d=δ(G). This will make the tightness result simpler to formulate. Let us first make a general observation about bipartite graphs that will come in handy in a moment. Recall that bipartite graphs are graphs that can be seperated into a disjoint union of two sets XXX and YYY with edges only between these two sets. Lemma Bipartite graphs cannot contain cycles of odd length (where length refers to the number of edges along the path). Equivalently, a cycle v1,…,vn,v1v_1, &#92;dots, v_n, v_1v1​,…,vn​,v1​ with nnn odd cannot exist. First, notice that any path in a bipartite graph consists of alternating vertices from both sets, because a vertex is only connected to vertices from the other set. Therefore any path of odd length must have start and end vertices in different sets, which cannot possibly form a cycle where start and end vertex are the same. The construction exhibiting tightness is a simple bipartite construction. We will construct a graph with 2d+12d+12d+1 vertices and show that this graph does not contain a Hamiltonian cycle. Consider vertices v1,…,v2d+1v_1, &#92;dots, v_{2d+1}v1​,…,v2d+1​ and let “even” vertices be those with an even index while “odd” vertices refer to those with an odd index. We connect every even vertex only to all other odd vertices and vice-versa. This construction can also be compactly written as Kd+1,dK_{d+1, d}Kd+1,d​ using standard graph theory notation. There are d+1d+1d+1 odd vertices and ddd even vertices, i.e. we are “barely” violating the degree conditions of the initial theorem. Even vertices have degree deven=⌈2d+12⌉=d+1d_{&#92;text{even}} = &#92;lceil &#92;frac{2d+1}{2} &#92;rceil = d + 1deven​=⌈22d+1​⌉=d+1 while odd vertices have degree dodd=⌊2d+12⌋=dd_{&#92;text{odd}} = &#92;lfloor &#92;frac{2d+1}{2} &#92;rfloor = ddodd​=⌊22d+1​⌋=d. Notice however, that this graph is clearly bipartite: Color say all even vertices red and all odd vertices blue, then by construction vertices of the same parity are not connected. But bipartite graphs cannot contain odd-length cycles as seen in the lemma above, which shows that this construction cannot contain a Hamiltonian cycle. Ore’s theorem Finally, let’s consider a generalization of Dirac’s theorem. The Norwegian mathematician Øystein Ore published the following theorem in a one-page paper in 1960[4]: Theorem (Ore, 1952) Let G=(V,E)G = (V, E)G=(V,E) be a graph with ∣V∣≥3|V| &#92;geq 3∣V∣≥3. If for every pair of non-adjacent vertices uuu and vvv with {u,v}∉E&#92;{u, v&#92;} &#92;not &#92;in E{u,v}∈E we have deg⁡G(u)+deg⁡G(v)≥∣V∣&#92;deg_G(u) + &#92;deg_G(v) &#92;geq |V|degG​(u)+degG​(v)≥∣V∣, then GGG contains a Hamiltonian cycle. This observation essentially follows from the proofs presented above. In the previous proofs, we repeatedly made use of the fact that two disconnected vertices can be connected through two adjacent neighbors. The condition that deg⁡G(u)+deg⁡G(v)≥∣V∣&#92;deg_G(u) + &#92;deg_G(v) &#92;geq |V|degG​(u)+degG​(v)≥∣V∣ for two non-adjacent vertices ensures exactly this: The neighborhoods N(u)&#92;mathcal{N}(u)N(u) and N(v)&#92;mathcal{N}(v)N(v) must intersect. We will prove this by contrapositive: Assume for sake of contradiction that Ore’s theorem is false, i.e. there exists a graph with ∣V∣≥3|V| &#92;geq 3∣V∣≥3 satisfying deg⁡G(u)+deg⁡G(v)≥∣V∣&#92;deg_G(u) + &#92;deg_G(v) &#92;geq |V|degG​(u)+degG​(v)≥∣V∣ for {x,y}∉E&#92;{ x, y &#92;} &#92;not &#92;in E{x,y}∈E that does not contain a Hamiltonian cycle. Let GGG be the the one with a maximum number of edges among those. Notice that GGG must contain a non-edge {x,y}∉E&#92;{x, y&#92;} &#92;not &#92;in E{x,y}∈E, as the complete graph K∣V∣K_{|V|}K∣V∣​ clearly contains a Hamiltonian cycle. Therefore we know the statement does not just hold vacuously. Now, adding {x,y}&#92;{x, y&#92;}{x,y} to GGG must necessarily close a Hamiltonian cycle x=v1,…,vn=yx = v_1, &#92;dots, v_n = yx=v1​,…,vn​=y by our choice of GGG. Here we can however again apply case 3 of the induction proof (with the knowledge that ∣N(x)∣+∣N+(y)∣≥∣V∣|&#92;mathcal{N}(x)| + |&#92;mathcal{N}^+(y)| &#92;geq |V|∣N(x)∣+∣N+(y)∣≥∣V∣) to conclude that {x,y}&#92;{x, y&#92;}{x,y} was not necessary to close the Hamiltonian cycle. There must be an edge vivi+1v_i v_{i+1}vi​vi+1​ in the path, where also both {x,vi+1}∈EG&#92;{x, v_{i+1}&#92;} &#92;in E_G{x,vi+1​}∈EG​ and {vi,y}∈EG&#92;{v_i, y&#92;} &#92;in E_G{vi​,y}∈EG​. We obtain a cycle C=x,vi+1,…,y,vi,…,xC = x, v_{i+1}, &#92;dots, y, v_i, &#92;dots, xC=x,vi+1​,…,y,vi​,…,x in GGG, a contradiction. Further reading Wikipedia: Hamiltonian Path Wikipedia: Ore’s theorem Dirac’s original paper: https://doi.org/10.1112/plms/s3-2.1.69 Overview of notation Complete graph KnK_nKn​ on nnn vertices Neighborhood N(v)&#92;mathcal{N}(v)N(v): set of vertices adjacent to vvv Extended neighborhood N+(u)&#92;mathcal{N}^+(u)N+(u) over an order of vertices: sucessors of neighbors of uuu N+(u):={vi+1 ∣ vi∈N(u)}&#92;mathcal{N}^+(u) := &#92;{ v_{i+1} &#92;;&#92;vert&#92;; v_i &#92;in &#92;mathcal{N}(u)&#92;}N+(u):={vi+1​∣vi​∈N(u)} Minimum degree δ(G):=min⁡v∈Vdeg⁡G(v)&#92;delta(G) := &#92;min_{v &#92;in V} &#92;deg_G(v)δ(G):=minv∈V​degG​(v) References Dirac, G.A. (1952), Some Theorems on Abstract Graphs. Proceedings of the London Mathematical Society, s3-2: 69-81. https://doi.org/10.1112/plms/s3-2.1.69 ↩︎ ↩︎ Pósa, L. (1976). Hamiltonian circuits in random graphs. Discrete Mathematics, 14, 359-364. https://doi.org/10.1016/0012-365X(76)90068-6 ↩︎ Diestel, R. (2017). Graph theory. Graduate texts in mathematics. https://doi.org/10.1007/978-3-662-53622-3 ↩︎ Ore, O. (1960). Note on Hamilton Circuits. The American Mathematical Monthly, 67(1), 55–55. https://doi.org/10.2307/2308928 ↩︎",
            "id": "https://www.umcconnell.net/posts/2024-07-31-dirac-theorem-hamiltonian/",
            "tags": ["posts", "math", "graph theory"]
        },
        {
            "title": "Kleitman-Winston Algorithm",
            "url": "/posts/2024-03-19-kleitman-winston/",
            "updated": "2024-03-19T00:00:00Z",
            "description": "Graph containers &amp; bounds on the number of independent sets in a locally dense graph.",
            "content": "Overview We will show that for a locally dense graph we can give a strong upper bound on the number of independent sets of a certain size. This specific method for graphs is an instance of the so-called container method , that allows to give bounds on structures appearing in larger objects with specific local properties. More specifically as applied to graph theory, this turns out to be quite helpful in proving lower bounds in Ramsey theory . The proof presented here follows the one presented in the survey paper by Samotij [1] using methods originally presented in the paper by Winston and Kleitman [2]. Some elementary knowledge of graph theory is helpful, such as the notion of independent sets and induced subgraphs, but I try to be as explicit and clear as possible. I will try to stick to common graph theoretical notation, but for the sake of both readability and completeness an overview of notation is given at the end of the post. Basic bounds Let’s start with some basic bounds on the number of independent sets ∣I(G)∣|&#92;mathcal{I}(G)|∣I(G)∣ in a graph GGG. Recall that an independent set is a set of vertices in which no two are connected by an edge. If α(G)&#92;alpha(G)α(G) refers to the independence number, ie. the size of the largest independent set in GGG, we can certainly say that 2α(G)≤∣I(G)∣ 2^{&#92;alpha(G)} &#92;leq |&#92;mathcal{I}(G)| 2α(G)≤∣I(G)∣ because every subset of the largest independent set is itself an independent set (recall that 2∣N∣2^{|N|}2∣N∣ is the number of different subsets that can be formed from a set NNN). Similarly, we can give an upper bound of ∣I(G)∣≤∑k=0α(G)(∣V(G)∣k) |&#92;mathcal{I}(G)| &#92;leq &#92;sum_{k=0}^{&#92;alpha(G)} &#92;binom{|V(G)|}{k} ∣I(G)∣≤k=0∑α(G)​(k∣V(G)∣​) as every independent set is a subset of size at most α(G)&#92;alpha(G)α(G) over the vertices of GGG. Theorem Statement We will now bound the number of independent sets of a certain size in a locally dense graph by showing that every independent set is part of a small container. These containers are constructed with the Kleitman-Winston algorithm. By counting these countainers, we can estimate the number of independent sets. The tightness property of the containers then allows us to give useful bounds on the number of independent sets. Let us now turn to the actual theorem. For N,R,q∈NN, R, q &#92;in &#92;mathbb{N}N,R,q∈N and β∈R&#92;beta &#92;in &#92;mathbb{R}β∈R with β∈[0,1]&#92;beta &#92;in [0, 1]β∈[0,1], let GGG be a graph on NNN vertices satisfying: N≤Reβq(1)&#92;tag{1} N &#92;leq R e^{&#92;beta q} N≤Reβq(1) In addition, we also require that G must be a β&#92;betaβ-locally dense graph. That is, for every vertex subset A⊆V(G)A &#92;subseteq V(G)A⊆V(G) of size at least RRR we have the following lower bound on the number of edges in the induced subgraph G[A]G[A]G[A]: eG(A)≥β(∣A∣2)(2)&#92;tag{2} e_G(A) &#92;geq &#92;beta &#92;binom{|A|}{2} eG​(A)≥β(2∣A∣​)(2) Note that this corresponds to the situation where the subgraph spanned by AAA over GGG contains at least a β&#92;betaβ-fraction of the edges of the corresponding complete graph over AAA, or in other words, that the average degree of AAA is at least β(∣A∣−1)&#92;beta (|A| - 1)β(∣A∣−1). Theorem Given such a β&#92;betaβ-locally dense graph GGG satisfying (1) and (2), we can construct up to (Nq)&#92;binom{N}{q}(qN​) small containers C1,…,CiC_1, &#92;dots, C_iC1​,…,Ci​ for 1≤i≤(Nq)1 &#92;leq i &#92;leq &#92;binom{N}{q}1≤i≤(qN​) of size at most R+qR + qR+q. Every independent set of size exactly q+kq + kq+k for k≤qk &#92;leq qk≤q belongs to a container CiC_iCi​. For the number of independent sets in GGG of size exactly q+kq + kq+k we obtain: ∣I(G,q+k)∣≤(Nq)(Rk)(3)&#92;tag{3} |&#92;mathcal{I}(G, q + k)| &#92;leq &#92;binom{N}{q} &#92;binom{R}{k} ∣I(G,q+k)∣≤(qN​)(kR​)(3) Algorithm Before describing the algorithm, let us fix a few technicalities. We need the notion of max-degree ordering to ensure high-degree vertices are quickly removed from the graph and the container quickly shrinks. For a vertex set A⊆V(G)A &#92;subseteq V(G)A⊆V(G), the max-degree ordering (v1,…,v∣A∣)(v_1, &#92;dots, v_{|A|})(v1​,…,v∣A∣​) is defined by the degree of vertices over the induced subgraph G[A]G[A]G[A] in descending order, where potential ties are broken by a fixed but arbitrary total order over V(G)V(G)V(G). In this case v1v_1v1​ has the highest degree, etc. The Kleitman-Winston algorithm works by iteratively removing high-degree vertices as outlined above: Kleitman-Winston algorithm .msg--algorithm ul ol { list-style-type: decimal; } Input: Independent set I∈I(G)I &#92;in &#92;mathcal{I}(G)I∈I(G), integer q≤∣I∣q &#92;leq |I|q≤∣I∣ Output: selected vertices SSS, available vertices AAA Procedure: Set available vertices A=V(G)A = V(G)A=V(G), selected vertices S=∅S = &#92;varnothingS=∅ Iterate for i=1,…,qi=1, &#92;dots, qi=1,…,q: Let A=(v1,…,v∣A∣)A = (v_1, &#92;dots, v_{|A|})A=(v1​,…,v∣A∣​) be ordered by max-degree Let tit_iti​ be the first index in the ordering of AAA such that vti∈Iv_{t_i} &#92;in Ivti​​∈I (i.e. first remaining vertex of III by max-degree ordering in induced subgraph G[A]G[A]G[A]). Move vtiv_{t_i}vti​​ from AAA to SSS Remove higher-degree vertices Xi=(v1,…,vti−1)X_i = (v_1, &#92;dots, v_{t_i - 1})Xi​=(v1​,…,vti​−1​) from AAA: A=A∖XiA = A &#92;setminus X_iA=A∖Xi​ Remove vtiv_{t_i}vti​​ and its neighborhood NA(vti)&#92;mathcal{N}_A(v_{t_i})NA​(vti​​) from AAA: A=A∖({vti}∪NA(vti))A = A &#92;setminus (&#92;{ v_{t_i} &#92;} &#92;cup &#92;mathcal{N}_A(v_{t_i}))A=A∖({vti​​}∪NA​(vti​​)) Output SSS and AAA The container of III is given by C:=S∪AC := S &#92;cup AC:=S∪A. Notice that the tightness of the container is apparent in that fact that S⊆I⊆CS &#92;subseteq I &#92;subseteq CS⊆I⊆C. Proof The algorithm maintains a few invariants, that help prove correctness: ∣A∣|A|∣A∣ decreases monotonically as we remove vertices in every iteration, while ∣S∣|S|∣S∣ increases monotonically. Also notice that the previous observation S⊆I⊆(S∪A)S &#92;subseteq I &#92;subseteq (S &#92;cup A)S⊆I⊆(S∪A) holds at every iteration of the algorithm. It is clear that the algorithm always succeeds in constructing the set of selected vertices SSS from q≤∣I∣q &#92;leq |I|q≤∣I∣ vertices of III. This is because the algorithm always selects the next highest degree vertex viv_ivi​ of III occuring in the subgraph G[A]G[A]G[A] at every step, i.e. no vertex vi∈Iv_i &#92;in Ivi​∈I is ever removed from AAA and not added to SSS as a discarded higher-degree vertex. In addition, the vertices of III form an independent set by assumption, and as such a vertex viv_ivi​ is never removed as part of the neighborhood of another selected vertex. Size of A To conclude tightness of the containers, we must show that the final AAA returned from the algorithm is sufficiently small. In fact, we will show that ∣A∣≤R|A| &#92;leq R∣A∣≤R. In the following, we will denote by AiA_iAi​ the set of available vertices at the beginning of the i-th iteration of the algortithm, and by Ai′=Ai∖XiA&amp;#x27;_i = A_i &#92;setminus X_iAi′​=Ai​∖Xi​ the set of available vertices after removing higher-degree vertices but before remoing vti∈Iv_{t_i} &#92;in Ivti​​∈I. First, note that by the Handshaking lemma we obtain an expression for the average degree of vertices: 1∣V∣∑v∈Vdeg(v)=2∣E∣∣V∣(4)&#92;tag{4} &#92;frac{1}{|V|} &#92;sum_{v &#92;in V} deg(v) = &#92;frac{2|E|}{|V|} ∣V∣1​v∈V∑​deg(v)=∣V∣2∣E∣​(4) Suppose for sake of contradiction ∣A∣&amp;gt;R|A| &amp;gt; R∣A∣&amp;gt;R for the final set of available vertices. Then it must be that the vti∈Sv_{t_i} &#92;in Svti​​∈S selected in every iteration must have been selected from a set of size at least RRR, even after removal of other higher-degree vertices (recall that ∣A∣|A|∣A∣ decreases monotonically throughtout the algorithm). Or, in other words, at the start of the i-th iteration with currently available vertices AiA_iAi​ and higher-degree vertices XiX_iXi​ scheduled for removal, ∣Ai′∣:=∣Ai∖Xi∣&amp;gt;R|A&amp;#x27;_i| := |A_i &#92;setminus X_i| &amp;gt; R∣Ai′​∣:=∣Ai​∖Xi​∣&amp;gt;R. Using the bound (2) on the edge-count: eG(Ai′)≥β(∣Ai′∣2)=β∣Ai′∣(∣Ai′∣−1)2 e_G(A&amp;#x27;_i) &#92;geq &#92;beta &#92;binom{|A&amp;#x27;_i|}{2} = &#92;beta &#92;frac{|A&amp;#x27;_i|(|A&amp;#x27;_i|-1)}{2} eG​(Ai′​)≥β(2∣Ai′​∣​)=β2∣Ai′​∣(∣Ai′​∣−1)​ As we choose vtiv_{t_i}vti​​ with maximum degree from Ai′A&amp;#x27;_iAi′​, we know vtiv_{t_i}vti​​ must at least have the average degree (4) of Ai′A&amp;#x27;_iAi′​: deg⁡Ai′(vti)≥2eG(Ai′)∣Ai′∣≥β(∣Ai′∣−1)&#92;deg_{A&amp;#x27;_i}(v_{t_i}) &#92;geq &#92;frac{2e_G(A&amp;#x27;_i)}{|A&amp;#x27;_i|} &#92;geq &#92;beta (|A&amp;#x27;_i| - 1) degAi′​​(vti​​)≥∣Ai′​∣2eG​(Ai′​)​≥β(∣Ai′​∣−1) Recalling the definition of ∣Ai′∣|A&amp;#x27;_i|∣Ai′​∣: ∣Ai′∣−1=∣Ai∖Xi∣−1=∣Ai∣−∣Xi∣−1∣Ai∣−(ti−1)−1=∣Ai∣−ti&#92;begin{aligned} |A&amp;#x27;_i| - 1 = |A_i &#92;setminus X_i| - 1 &amp;amp;= |A_i| - |X_i| - 1 &#92;&#92; |A_i| - (t_i - 1) - 1 &amp;amp;= |A_i| - t_i &#92;end{aligned} ∣Ai′​∣−1=∣Ai​∖Xi​∣−1∣Ai​∣−(ti​−1)−1​=∣Ai​∣−∣Xi​∣−1=∣Ai​∣−ti​​ In total we remove ∣Xi∣+∣N(vti)∣+1|X_i| + |&#92;mathcal{N}(v_{t_i})| + 1∣Xi​∣+∣N(vti​​)∣+1 vertices from AiA_iAi​ in every round. Putting everything together: ∣Ai+1∣≤∣Ai∣−(∣Xi∣+∣N(vti)∣+1)≤∣Ai∣−(∣Xi∣+deg⁡Ai′(vti))≤∣Ai∣−(ti+β(∣Ai∣−ti))≤∣Ai∣−β∣Ai∣=∣Ai∣(1−β)&#92;begin{aligned} |A_{i+1}| &amp;amp;&#92;leq |A_i| - (|X_i| + |&#92;mathcal{N}(v_{t_i})| + 1) &#92;&#92; &amp;amp; &#92;leq |A_i| - (|X_i| + &#92;deg_{A&amp;#x27;_i}(v_{t_i})) &#92;&#92; &amp;amp;&#92;leq |A_i| - (t_i + &#92;beta (|A_i| - t_i) ) &#92;&#92; &amp;amp;&#92;leq |A_i| - &#92;beta|A_i| = |A_i| (1 - &#92;beta) &#92;end{aligned} ∣Ai+1​∣​≤∣Ai​∣−(∣Xi​∣+∣N(vti​​)∣+1)≤∣Ai​∣−(∣Xi​∣+degAi′​​(vti​​))≤∣Ai​∣−(ti​+β(∣Ai​∣−ti​))≤∣Ai​∣−β∣Ai​∣=∣Ai​∣(1−β)​ where we used that β≤1&#92;beta &#92;leq 1β≤1 for the last inequality We find that the set of available vertices AAA shrinks at least by a factor of (1−β)(1 - &#92;beta)(1−β) in every iteration. Together with the fact that the initial set AAA is V(G)V(G)V(G) we obtain a contradiction to the initial condition (1) on the number of vertices in GGG: ∣A∣≤(1−β)qN≤e−βqN≤R(5)&#92;tag{5} |A| &#92;leq (1 - &#92;beta)^q N &#92;leq e^{-&#92;beta q} N &#92;leq R ∣A∣≤(1−β)qN≤e−βqN≤R(5) Here we used the well-known inequality (1+x)≤ex(1 + x) &#92;leq e^x(1+x)≤ex. After qqq iterations, the initial set of available vertices has necessarily shrunk to a set of at most RRR vertices. Final bound Let us now finally give the bound on the number of independent sets of size exactly q+kq + kq+k. The bound (3) follows from the observation, that there are at most (Nq)&#92;binom{N}{q}(qN​) different ways to choose SSS and therefore the first qqq vertices of an independent set, and at most (Rk)&#92;binom{R}{k}(kR​) different ways to choose the kkk remaining vertices from AAA, which has size at most RRR. Another useful, but less sharp bounds, can be obtained from one of the various inequalities on the binomial coefficient: ∣I(G,q+k)∣≤Nqq!(Rk)(6)&#92;tag{6} |&#92;mathcal{I}(G, q + k)| &#92;leq &#92;frac{N^q}{q!}&#92;binom{R}{k} ∣I(G,q+k)∣≤q!Nq​(kR​)(6) Wikipedia has an extensive collection of such bounds. Overview of notation Vertex set V(G)V(G)V(G) Edge count eG(X)e_G(X)eG​(X): Number of edges in GGG on vertex set XXX Neighborhood N(v)&#92;mathcal{N}(v)N(v): set of vertices adjacent to vvv Induced subgraph G[A]G[A]G[A]: Obtained from GGG by keeping all vertices in AAA and their edges among them Independence number α(G)&#92;alpha(G)α(G): Size of largest independent set in GGG Independent sets I(G)&#92;mathcal{I}(G)I(G): Collection of all independent sets in GGG Independent sets I(G,m)&#92;mathcal{I}(G, m)I(G,m): Collection of all independent sets in GGG of size exactly mmm Further reading Some ressources for further details, including applications to various combinatorial problems and extensions of the container method to hypergraphs, are given below: Wikipedia: https://en.wikipedia.org/wiki/Container_method Survey paper by Samotij: https://arxiv.org/pdf/1412.0940.pdf Lecture notes by Liu: https://homepages.warwick.ac.uk/staff/H.Liu.9/topic-comb-lecture15.pdf References https://arxiv.org/pdf/1412.0940.pdf ↩︎ https://doi.org/10.1016/0012-365X(82)90204-7 ↩︎",
            "id": "https://www.umcconnell.net/posts/2024-03-19-kleitman-winston/",
            "tags": ["posts", "math", "combinatorics", "graph theory"]
        },
        {
            "title": "Meta Blog: Advanced",
            "url": "/posts/2021-03-31-meta-blog-advanced/",
            "updated": "2021-03-31T00:00:00Z",
            "description": "A blog post on how to create your own blog (posts) with 11ty. Part II: Advanced technical details.",
            "content": "Part 1 of this series went through the basic setup and customization of this blog for your own purposes. In this part, I will go through a few technical details, tips and additional notes, that can allow you to extend the site and troubleshoot errors. This part can also serve as a project reference or documentation of some sort. Overview Before we go into detail about different aspects of the website, here’s a quick overview of all the different folders and what they contain: . ├── config Configuration for plugins (e.g. markdown-it, KaTeX) ├── src │ ├── assets Website assets │ │ ├── fonts │ │ ├── icons │ │ ├── images │ │ │ ├── favicon Icons and images for Web App │ │ │ └── posts Images in posts │ │ ├── other Other assets (e.g. PGP key) │ │ ├── scripts JavaScript │ │ │ └── modules │ │ └── styles │ │ ├── base Base styles (e.g. markdown, CSS reset) │ │ ├── components Styling for various components │ │ └── utils CSS utilities │ ├── components Nunjucks components (e.g. card, tags) │ ├── data Website metadata │ ├── includes Nunjucks includes (e.g. footer, navbar) │ ├── layouts Nunjucks page layouts (e.g. base, post) │ ├── pages Concrete pages (e.g. about, post archive) │ └── posts Markdown posts └── utils JS utilities (e.g. filters, shortcodes) Styling Styling is done using SCSS . All stylesheets are located in src/assets/styles . The styles are then imported and bundled in main.scss. The styles are grouped into three main folders: base : The base styling comprises basic stylesheets used globally throughout the page, such as normalization or typography. These styles are very generic, meaning you probably want to modify styles in different places, such as the components/ folder for specific components. components : These styles consist of more specific styles tailored to certain components, such as the footer, the navigation or the post tags. This is probably the best place to modify or add new styles when customizing the website. utils : The utilities are mostly SCSS-specific functions, that make use of SCSS’s scripting features. This is also where the global variables for colors, breakpoints, etc. are defined for the entire page. The compilation process, including minification, and error handling is defined in the styles.11ty.js file. In practice, you shouldn’t need to modify this file. Theming The blog supports adaptive light and dark themes out of the box (based on the prefers-color-scheme media query). The different color palettes are defined in _variables.scss under the $themes key. Individual properties are themed using the t SCSS mixin . This is for example how links are themed throughout the blog: a { @include t(color, &#39;link-color&#39;); text-decoration: underline; } The mixin takes a CSS property as the first argument, followed by a variable name referencing the desired color. This name refers to a field from the $themes map, which means you can only refer to colors defined as part of a theme. The mixin takes additional optional arguments, which you can find in the mixin’s source . Breakpoints Breakpoints are also quickly defined using SCSS mixins. There are two mixins, mq and mq-down, which provide breakpoints starting at, and going up to, a certain width. The mixins take the name of a breakpoint, as defined in the global variables. An example use of breakpoints is when styling the navbar. The following declaration hides the navigation burger menu for large screens (starting at 940px in width) and up: @include mq(lg) { &amp;amp;__toggle { display: none; } // ... } Markdown Markdown files are compiled using markdown-it . The configurations for markdown-it and it’s plugins are located in the config/ folder. The styles for Markdown documents, such as posts, are located in src/assets/styles/base/_markdown.scss . Note that Markdown documents must be wrapped in an element with class .markdown for the styles to take effect. You can thus use the Markdown styles in HTML/Nunjucks files by wrapping sections in such an element. Plugins The following markdown-it plugins are used in this blog: markdown-it-anchor @iktakahiro/markdown-it-katex Additionally, two custom plugins, one for the arrow icons after external links, and one for the anchor links when hovering over headings, are implemented in the config folder. Posts The blog supports several non-standard additions to Markdown, that add blog-specific functionality to your posts. Nunjucks expressions You can write Nunjucks markup directly in your markdown posts, just as you would in the other pages. Just wrap the expression between two curly braces: {{ Nunjucks expression }}. For example, you can conveniently link to the page’s code repository, directly in Markdown, like this: You can find the source code [here]({{ meta.code.repo }}). This gives: You can find the source code here . Shortcodes Shortcodes are another very practical feature of Nunjucks in Markdown. All shortcodes are defined in utils/shortcodes.js , and you can add more. Shortcodes expand to a longer parameterized expression. Standard shortcodes only take arguments, such as in this example: {% &#39;icon pencil&#39; %} This produces an SVG element: The standard shortcodes available out of the box are: icon to embed icons from src/assets/icons/ ytvideo to embed YouTube videos based on their id There are also paired shortcodes, that wrap a markup section, such as this one: {% msg &#39;info&#39; %} An informative message that **even** supports _Markdown_! {% endmsg %} This produces the following: INFO An informative message that even supports Markdown! The paired shortcodes available out of the box are: msg for message boxes details for an expandable HTML summary/details element KaTeX You can also include math expressions in your post. The expressions are compiled using KaTeX , which allows you to write TeX-like expressions. All KaTeX configurations are located in config/markdown-it/katex.js . For inline math expressions, wrap your code in single dollar signs: $math$. For example, you can easily include fractions: A fraction $&#92;frac{a}{b}$ includes a numerator $a$ and a denominator $b$. This produces the following text: A fraction ab&#92;frac{a}{b}ba​ includes a numerator aaa and a denominator bbb. For blocks of math, wrap your code in double dollar signs: $$ math $$. For example, you can display Euler’s identity: Euler&#39;s identity: $$e^{i &#92;pi} = -1$$ This results in: Euler’s identity: eiπ=−1e^{i &#92;pi} = -1 eiπ=−1 You can find all supported expressions and formatting options in the KaTeX docs . Nunjucks Nunjucks is used as the templating language for the blog. There are several places where Nunjucks is used: src/components/ : Nunjucks allows imports of so-called macros , which are used to represent the components. Macros are similar to functions and accept arguments to construct a parameterized output. src/includes/ : Nunjucks’ includes allow you to literally include chunks of markup as reusable units. This is used for non-variant parts of the website, such as the footer, header, etc… src/layouts/ : Layouts are page skeletons that are used as a common base among pages. The base layout is the HTML skeleton for all other pages and layouts. The post layout extends this base layout to include additional stylesheets for code highlighting or the utterances comment widget. src/pages/ : The pages represent concrete pages of the website, such as the About page or the Projects page. These are written with Nunjucks, but already include front matter for 11ty. 11ty Most of the 11ty-related configuration is placed in the .eleventy.js file. Note, that if you are serving this website from a subproject on Github pages, i.e. when you are not using GH_USERNAME.github.io, but rather GH_USERNAME.github.io/PROJECT/, you must change the 11ty pathPrefix field in the configuration file. The setting is commented out in this website’s configuration. In development mode (npm run dev), Markdown posts and images in the src/posts/drafts/ folder will also be built and served. They do, however, not appear in production mode and are not tracked by git. Icons All icons placed in the src/assets/icons/ folder will be grouped into an SVG sprite to improve loading time. The icons can then be used via the icon shortcode. Plugins The 11ty plugins used in this blog are: @11ty/eleventy-plugin-rss @11ty/eleventy-plugin-syntaxhighlight @11ty/eleventy-navigation You can find the full list of available plugins in the 11ty docs Webpack &amp;amp; Babel All JavaScript code referenced in src/assets/scripts/main.js is transpiled to backwards compatible JavaScript using babel to support older browsers. The code files are then bundled using webpack , with the webpack configuration file located at src/assets/scripts/scripts.11ty.js . The bundling process uses an in-memory file system to bundle the scripts in memory and return the bundled result as a reusable JS string. Github The site is automatically built and linted using the provided Github Actions workflows. The workflow files are located in the .github/workflows/ folder. The lint action uses Prettier to check the code for styling and formatting issues. See the VSCode section for information on the Prettier extension to automatically format your code when you save. VSCode For VSCode users, I recommend installing the Prettier extension to automatically format your code and posts on save. All recommended plugins are listed in the .vscode/ folder. These recommendations should be automatically suggested when first opening the project in the editor. That was it. Thanks for reading!",
            "id": "https://www.umcconnell.net/posts/2021-03-31-meta-blog-advanced/",
            "tags": ["posts", "blog", "webdev"]
        },
        {
            "title": "Meta Blog: Basics",
            "url": "/posts/2021-03-30-meta-blog-basics/",
            "updated": "2021-03-30T00:00:00Z",
            "description": "A blog post on how to create your own blog (posts) with 11ty. Part I: The basics.",
            "content": "In my Hello Internet post I announced my intention to write a post on how I set up this blog and how you can do the same. The time has now finally come, and the original idea has morphed into a two-part series. Enjoy! INFO This tutorial is primarily meant for beginners. It explains cloning this blog from Github, personalizing it with custom icons, name and color, and finally publishing it with Github pages. Part 2 goes further into the technical details of the blog. If you prefer getting started right away, feel free to skip to the Getting started section. Also, there is a video tutorial available for a visual guide on the setup process. Static Site Before we dive into building a static website, it is helpful to quickly look at what a static website actually is. On Wikipedia , a static website is defined as “[…] a web page that is delivered to the user’s web browser exactly as stored, in contrast to dynamic web pages […]”. Concretely, this means no dynamic pages, no fancy PHP scripts and no on-page user login. Only plain good ol’ HTML, with some additional CSS and JavaScript Why would one want such a boring thing? Well, it turns out there’re quite a lot of advantages to static sites, if all you have is static content. Static sites are… faster: only HTML, CSS, JS and images are served safer: no login systems, etc. means a minimal attack surface more accessible: an old browser and a slow internet connection is fine cheaper: free hosting available, e.g. with Github Pages or Netlify … than their dynamic counterparts. A static site doesn’t necessarily mean being limited in functionality, or having a site consisting of only text and images. There are a lot of possibilities on the front-end, ranging from embedded YouTube videos and RSS feeds to a comment system (more on this later on and in Part 2). SSGs When creating your static blog, it can be helpful to use a Static Site Generator (SSG). An SSG helps to make the development and editing process comfortable. Instead of writing your posts in plain HTML, you can write them in Markdown and have the SSG convert your posts to HTML files. This is a similar idea to the concept of compiling code from a higher level language (such as C or Rust) to machine code, allowing you to write fast code in a simpler and human-readable form. The process of “compiling” your website will be referred to as building in the following. In this guide we’ll be talking about setting up and configuring an SSG called 11ty (pronounced eleventy). 11ty runs on top of Node , which allows you to benefit from the massive JavaScript ecosystem and write your own plugins in JavaScript. Getting started Prerequisites Before we get started with the setup, make sure you have the following prerequisites: git: You can find installation instructions for all platforms here github: You can create an account here node: You can download node from here Cloning Start by cloning my blog from the Github repository. In a terminal, run: git clone https://github.com/umcconnell/umcconnell.github.io.git blog cd blog/ This will clone the code into the folder blog/. Installing In the blog root folder, install the required dependencies using npm: npm install The installation might take a minute or two. Running Once the installation has finished, you are ready to run the build process and serve the blog on your localhost. Run: npm run dev You should be able to navigate to localhost:8080 and see the blog as it appears here. Personalizing Now the blog is ready for customization. To do that, you will need to change four files: package.json LICENSE src/site.webmanifest src/data/meta.json package.json The package.json file describes your node project. It mainly contains information about the project’s source code and package dependencies. You can add your name to the author field and change the description field to your liking. The name and repository.url fields should contain your project name and source code repository. The project name should be GH_USERNAME.github.io, the repository url http://github.com/GH_USERNAME/GH_USERNAME.github.io accordingly. Replace GH_USERNAME with your Github username. LICENSE Modify the LICENSE file to mention your name as the Copyright owner in the first line. src/site.webmanifest The src/site.webmanifest file describes the web app behavior of your blog. This controls how the website will be presented when a user adds the blog to their home screen, i.e. installing the web app. Here, you can change the name and short_name field. src/data/meta.json Finally, the last file to personalize is src/data/meta.json. This file contains important meta-information about the blog, such as the author, the source and comment repositories for the blog, etc. Make sure to change the title and author fields, which will for example change the footer or the about page of the blog. The url should contain the final URL of the website, i.e. GH_USERNAME.github.io, where GH_USERNAME is your Github username. Custom domain If you do not want to use a custom domain name for your website, such as example.com, set the custom_domain field to false. If you own a domain and want to set it up for your blog, you can specify your custom domain in this field. This then generates a CNAME file in the build output for you to configure with Github pages. See this article in the Github docs on for instructions on how to set up a custom domain for your site. Most importantly however, change the fields in the code section of the webmanifest: The repo entry should point to the Github repository of the website (https://github.com/GH_USERNAME/GH_USERNAME.github.io). The comments field points to the repository that will save user comments from the blog. This should be GH_USERNAME/comments. We’ll create this repo later. Once you’ve saved the files, you should be able to see your name appear on the blog. Icons To change the icons that appear in the header, when installing the web app, etc., navigate to src/assets/images/. The avatar, displayed in the header of the website, can be changed by replacing the avatar.png file with your own image. You may also change the email.png image, which is displayed in the about page as your contact information. The icons used for the web app are located in the favicon/ subfolder. When replacing these icons with your own, custom icons, make sure to keep the naming and size of the individual files. Colors If you want, you can further personalize the blog with custom colors, styles, and more. All styles and related configurations are located in the src/assets/styles/ folder. Stylesheets are written in SCSS . Note that all valid CSS is valid SCSS, which means you can style the blog in plain CSS if that is more familiar to you. More specifically, the colors used throughout the web page can be changed in the utils/_variables.scss file. The main theme color is defined by the $brand-color-primary variable.These variables are used in all the other styles, which means it should be enough to change the colors in this file. Comments The last thing to do personalize your new blog is to activate the comments functionality. The blog uses a free service called utterances , which takes care of managing your comments. It will display a widget at the bottom of your blog post, that lets users leave a comment. Note that the comments widget is not displayed when you are in development mode and serving your blog on localhost (npm run dev). It will appear in the online version. The comments are stored in a Github repository, which means you don’t need to worry about storing your comments. To be able to store comments in a Github repository on your behalf, you will need to install the the utterances Github app . Follow the link and click the install button. You will need to grant the app access to your repositories. You can later restrict access to the comments repo only in your settings . First post Your new blog should probably contain a introductory post. All posts are written in Markdown and located in src/posts/. Go ahead and delete the posts already in the folder (all files ending with .md). Next, create a file called YYYY-MM-DD-hello-world.md, where YYYY, MM and DD refers to the current date (e.g. 2021-03-14). You place the following text into the file and modify it to your liking. Changes you make to the file should be reflected instantaneously in your web browser. --- title: Hello World date: 2021-03-14 description: &gt; Hello World introductory post. tags: - hello - world - intro --- Hi everyone! This is my _brand new_ blog. **Enjoy**! That’s it! You’re blog is ready to go online. Publishing After customizing the blog, we are now ready to publish our blog. We will publish the blog on Github pages . After following these steps, your page will be available at https://GH_USERNAME.github.io. Committing Start by committing all your customization changes to git. In the root folder of the blog, run: git add . git commit -av Creating Repositories Next, we’ll create the Git repositories that will hold the source code of your blog and the comments to your posts. In your web browser, navigate to github.com/new to create a new repository. For the comments repo, enter comments as the repository name. Make sure, the repo visibility is set to “Public”, before hitting the “Create repository” button. Repeat this step for the repo that is going to hold the blog’s source code. Enter GH_USERNAME.github.io as repo name (where GH_USERNAME is your Github username) and select the visibility “Public”. Then, create the repository. You should see a set of instructions to publish your code. Note the instructions to “push an existing repository from the command line”. When executing these instructions in the root folder of your blog, you will need to change one command. Because you have cloned the original blog code from Github, it already has a remote git origin set. You will need to use set-url instead of add here: git remote set-url origin https://github.com/GH_USERNAME/GH_USERNAME.github.io.git git branch -M main git push -u origin main Github Pages The last step is to publish your pages using Github pages. In your repository containing the blog source, navigate to the “Settings” tab. Almost at the bottom of the page, you should find a “Github pages section”. From the source drop-down, select the “gh-pages” branch. After hitting the save button, your site should be available online. Video tutorial My friend Boldizsar Zopcsak and I recorded a video tutorial about this whole procedure a little while ago. The video goes through the basics of cloning, personalizing and publishing your next blog. Feel free to have a look: * { padding: 0; margin: 0; overflow: hidden; } html,body { height: 100%; } img,span { position: absolute; width: 100%; top: 0; bottom: 0; margin: auto; } span { display: flex; background-color: rgba(51, 51, 51, 40%); align-items: center; justify-content: center; font: 48px/1.5 sans-serif; color: white; text-shadow: 0 0 1em black; } ▶ &quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen title=&quot;Embedded Youtube Video. Click to play.&quot; loading=&quot;lazy&quot; &gt; For a look at the technical details of this blog, head over to Part 2 of this series.",
            "id": "https://www.umcconnell.net/posts/2021-03-30-meta-blog-basics/",
            "tags": ["posts", "blog", "webdev", "beginner"]
        },
        {
            "title": "Fibonacci in Rust",
            "url": "/posts/2021-03-13-fibonacci-rust/",
            "updated": "2021-03-13T00:00:00Z",
            "description": "This post goes through different approaches to generating the Fibonacci sequence in Rust. It compares the speed of these approaches using the benchmarking crate criterion.",
            "content": "You’ve probably already heard of the Fibonacci sequence. It is a sequence of numbers named after the mathematician Leonardo of Pisa , that’s generated using a simple rule, yet pops up in many unexpected places in math and nature, often in relation to the golden ratio. To generate the sequence, start with the sequence 1, 1. Then, generate the next element in the sequence by adding up the last two elements: 1, 1 1, 1, 2 1, 1, 2, 3 … Mathematically, this can elegantly be expressed using recursion. In this formula, n represents a given position in the sequence starting with 0. fib(n)={1if n≤1fib(n−2)+fib(n−1)if n&amp;gt;1fib(n) = &#92;begin{cases} 1 &amp;amp;&#92;text{if } n &#92;leq 1 &#92;&#92; fib(n-2)+fib(n-1) &amp;amp;&#92;text{if } n &#92;gt 1 &#92;end{cases} fib(n)={1fib(n−2)+fib(n−1)​if n≤1if n&amp;gt;1​ Implementation We will be implementing the Fibonacci logic using Rust. Rust is a programming language initially developed at Mozilla that can guarantee memory safety, while at the same time being super fast. We’ll try out different approaches and see which one runs fastest. If you want to follow along on your computer, you can find simple installation instructions for Rust and cargo, the Rust package manager, for just about any OS, on the Rust homepage: https://www.rust-lang.org/tools/install . Alternatively, you can also code along online on the Rust playground without having to install anything! Setup If you are not coding along on your machine, feel free to skip this section. First, let’s create a new Rust library project from the command-line using cargo: cargo new --lib rust_fibonacci cd rust_fibonacci/ The file src/lib.rs is where we’ll be writing source code later on. You can delete it’s pregenerated contents for now, as we won’t go through writing tests for such a simple program. Now, the only aspect missing is the benchmarking, so that we can compare the different approaches to calculating the Fibonacci sequence. To do this, we can use the criterion crate , which allows us to write benchmarks and run them using cargo. Add the following code to the Cargo.toml file, just below the [dependencies] section at the bottom: [dev-dependencies] criterion = &quot;0.3&quot; [[bench]] name = &quot;fibonacci_benchmark&quot; harness = false Create a directory called benches in the base directory and place an empty file called fibonacci_benchmark.rs into it. Once you’re done, the rust_fibonacci/ project directory content should look something like this: . ├── benches │ └── fibonacci_benchmark.rs ├── Cargo.lock ├── Cargo.toml └── src └── lib.rs #1: Standard INFO If you&#39;re using the Rust playground, just add all the code examples above the `main` function. The playground just allows you to use one single file to write your code in. Now, let’s get coding! Probably the most straightforward way to implement the Fibonacci sequence, would be to just start with two variables a and b, that keep track of the last two elements of the sequence and build from there. Let’s do that! Add this code to src/lib.rs: pub fn fib_standard(n: usize) -&gt; usize { let mut a = 1; let mut b = 1; for _ in 1..n { let old = a; a = b; b += old; } b } Notice the pub keyword: We use it, so that we can import the code from other files. This will be useful when benchmarking the functions later on. Here, we declare a and b as mut, i.e. mutable, to allow us to mutate or change their values. In Rust, all variables are imutable by default. We start our loop at 1, because the first two values are already defined and the range is non-inclusive for its end. #2: Recursion Another approach to implementing the Fibonacci algorithm would be to just translate the recursive mathematical definition from the introduction into Rust code. Add the following function in src/lib.rs: pub fn fib_recursive(n: usize) -&gt; usize { match n { 0 | 1 =&gt; 1, _ =&gt; fib_recursive(n-2) + fib_recursive(n-1), } } In this case, the match operator comes in really handy. It works just like the conditional function definition in math! It is short, clean and concise. This means we don’t have to write endless if { ... } else if { ... } else { ... } clauses. One last thing to note, is the implicit return. We did not have to use the return statement, because the last expression is automatically returned. However, it is important not to end with a semi-colon, which would make the function return nothing (or (), to be more precise). When we take a close look at this function, it might become clear that it is pretty inefficient. When calculating fib_recursive(n), we end up calculating the Fibonacci sequence twice every step down from n, although it would be enough to calculate the sequence once. This is where memoization comes in. Runtime complexity The recursive approach has the runtime complexity O(2n)O(2^n)O(2n). This is because the time complexity of fib_recursive(n) approximately doubles for every n, because it computes fib_recursive(n-1) and fib_recursive(n-2). If we want to be more exact about the statement “it approximately doubles”, we can say the following about this factor aaa: an=a(n−1)+a(n−2)∣:a(n−2)a2=a+1a=1±52 &#92;begin{aligned} a^n &amp;amp;= a^{(n-1)} &amp;amp;+ &amp;amp;a^{(n-2)} &#92;quad | : a^{(n-2)} &#92;&#92; a^2 &amp;amp;= a &amp;amp;+ &amp;amp;1 &#92;&#92; a &amp;amp;= &#92;frac{1 &#92;pm &#92;sqrt{5}}{2} &#92;end{aligned} ana2a​=a(n−1)=a=21±5​​​++​a(n−2)∣:a(n−2)1​ We can safely ignore the second solution 1−52&#92;frac{1 - &#92;sqrt{5}}{2}21−5​​, which is negative. This leaves us with a=1+52a = &#92;frac{1 + &#92;sqrt{5}}{2}a=21+5​​, the golden ratio . What a coincidence! The asymptotically tight bound on the running time of fib_recursive is thus Θ(an)&#92;Theta(a^n)Θ(an), where aaa is the golden ratio. You can find out more about asymptotic notation in computer science on Khan Academy . #3: Memoization We will use a std::collections::HashMap , which is similar to a dict in Python or an Object in JavaScript, to keep track of all the values we’ve already calculated. Then, we can quickly check, whether a given value has already been encountered and can return this, before wasting time on a redundant calculation. Add this code to your lib.rs file: use std::collections::HashMap; pub fn fib_memoization(n: usize, memo: &amp;amp;mut HashMap&amp;lt;usize, usize&gt;) -&gt; usize { if let Some(v) = memo.get(&amp;amp;n) { return *v; } let v = match n { 0 | 1 =&gt; 1, _ =&gt; fib_memoization(n-2, memo) + fib_memoization(n-1, memo), }; memo.insert(n, v); v } We first check, whether the current n is in the HashMap, by checking whether the value at n is Some. If no value has jet been recorded, memo.get(&amp;amp;n) will return None and the pattern won’t match. Next, we compute the sequence value just as when using plain recursion. The only difference is, that we save the value to our memo before returning it. Notice how we write &amp;amp;mut HashMap&amp;lt;usize, usize&amp;gt; in the function definition. This is part of Rust’s borrow checker, that ensure memory safety for our program. By declaring the memo as mutable, Rust ensures that only one part of the program has write access at a time and that no other part of the program can read from the memo while we have write access to it and might be modifying it unexpectedly. #4: Iterator One last way to implement the Fibonacci sequence that this post will cover is using Rust iterators. You might be familiar with this concept, especially if you’ve already used Generators in JavaScript or Iterators in Python . Rust iterators implement the Iterator trait and expose a next function, which returns the next element of the iterator or None, if the iteration is over. Lets implement this iterator principle using a struct. The struct will save the last two elements a and b of the sequence, starting at 1. It will then generate the next value just as in the standard approach: pub struct FibIterator { a: usize, b: usize } impl Default for FibIterator { fn default() -&gt; Self { FibIterator { a: 1, b: 1 } } } impl Iterator for FibIterator { type Item = usize; fn next(&amp;amp;mut self) -&gt; Option&amp;lt;Self::Item&gt; { let curr = self.a; self.a = self.b; self.b = curr + self.a; Some(curr) } } A few things to notice here. First, notice how we all methods of the struct are wrapped in impl blocks. This separates the struct definition from it’s methods, helping your code stay clean. Also, we write a default method that takes no arguments and returns an initialized FibIterator. As this method is not associated to a struct instance, i.e. an initialized FibIterator with concrete values for a and b, it is called an associated function. We can call these types of functions using ::. In this case, we would call FibIterator::default() to construct a new instance. The Iterator and Default traits are implemented using the impl Foo for Bar statement. In the impl block of the Iterator trait, we define a next function that just returns the sum of the two last elements in the sequence. This way, the iterator can just keep generating new integers of the sequence on demand. Because iterators in Rust are lazy, these integers are only generated when needed. INFO A trait is a set of common functions all structs must implement, to have this trait. In the case of Iterator, this is solely the next function. Traits are useful, because they allow other functions to accept different types, while making sure that all of these different types share a common interface. When implementing Iterator, this trait unlocks a whole set of other useful methods such as skip, take, filter, and many more, that all rely on the next method we implemented. These all come built-in with the trait and we don’t need any additional work to implement these. Iterators are an important part of Rust, as they allow to write code in a concise functional style, while incurring no additional performance. When compiling the code, Rust will optimize the operations away and turn the iterators into classical for loops in the background. That means you don’t have to choose between writing fast and clean code, you can do both! Bechmarking Finally, we will compare the different approaches by benchmarking the different functions. Add the following code to the benches/fibonacci_benchmark.rs file. Note that benchmarking does not seem possible on the online Rust playground. use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion}; use rust_fibonacci::*; use std::collections::HashMap; fn bench_fibs(c: &amp;amp;mut Criterion) { let mut group = c.benchmark_group(&quot;Fibonacci&quot;); for i in [20, 21].iter() { group.bench_with_input(BenchmarkId::new(&quot;Standard&quot;, i), i, |b, i| { b.iter(|| fib_standard(*i)) }); group.bench_with_input(BenchmarkId::new(&quot;Recursion&quot;, i), i, |b, i| { b.iter(|| fib_recursive(*i)) }); group.bench_with_input(BenchmarkId::new(&quot;Memoization&quot;, i), i, |b, i| { b.iter(|| { let mut memo = HashMap::new(); fib_memoization(*i, &amp;amp;mut memo); }) }); group.bench_with_input(BenchmarkId::new(&quot;Iterator&quot;, i), i, |b, i| { b.iter(|| { FibIterator::new().nth(*i).unwrap(); }) }); } group.finish(); } criterion_group!(benches, bench_fibs); criterion_main!(benches); This code creates a test group called Fibonacci and benchmarks the four different approaches using the same input. Run the benchmark in your terminal: cargo bench Once the benchmarks are done, you can view a nice HTML report in your browser by opening target/criterion/Fibonacci/report/index.html. Running on my machine gave me the following stats: You can clearly see, that the naive recursive solution is the least performant approach, as its execution time increases (exponentially, but not visible with 2 inputs) with the workload. The memoized version, in contrast, shows a great improvement, but it still incurs the performance overhead of initializing and managing the memo, making it less performant than the two last approaches. The iterator and standard seem to be indistinguishable. On my machine, the execution of the iterator takes ~34ns for both inputs, the standard approach around ~4.5ns for both inputs. You can find more detailed graphs and charts for every function in the corresponding target/criterion/Fibonacci/&amp;lt;APPROACH&amp;gt;/report/index.html folder. Conclusion We’ve implemented and benchmarked four different approaches to generating the Fibonacci sequence. Although the recursive solution is short and concise, it is by far the least performant and can become too slow to calculate for larger inputs. The memoized solution is interesting, in that it combines the conciseness of the recursive approach with a greater speed. The standard approach, on the other hand, seems to be the fastest, but it is arguably the least elegant. Finally, the iterator solution appears to be by far the most versatile while at the same time being very fast. Additionally, it allows the user to work with the sequence in a very convenient way, e.g. by filtering, mapping, etc. Overall, it becomes clear that iterators are a very versatile and performant aspect of Rust, that are also worth considering in other languages such as Python or JavaScript. The final code of this project is open source and available here: https://github.com/umcconnell/rust_fibonacci Feedback, questions, comments or improvements are welcome! Thanks for reading.",
            "id": "https://www.umcconnell.net/posts/2021-03-13-fibonacci-rust/",
            "tags": ["posts", "programming", "rust", "fibonacci"]
        },
        {
            "title": "Hello Internet",
            "url": "/posts/2021-03-11-hello-internet/",
            "updated": "2021-03-11T00:00:00Z",
            "description": "Kicking off my blog with the mandatory &quot;Hello World&quot; introductory post... More posts about software, technology and science to come!",
            "content": "Hi! This is the first post on my new blog, and I’m really excited. I hope to write more in the coming weeks and months, especially about technical and software-related topics. My goal is to write about current software side projects and things I’ve learned, all in the spirit of “Stay curious, keep learning”. Depending on how that works out, I’ll adapt if needed. Outlook A few topics I’d like to cover soon are AI, Rust and how I set up this blog, to give some ideas in case you would like to do the same. In the meantime, as this blog is entirely open source, I invite you to check out the source code on Github, fork it, make it your own, or whatever you want. Why?!? I hope to learn something useful from this experience and gain some more experience building websites. Writing down ideas and summarizing problems is a good exercise, all while improving writing skills. A blog also let’s me document findings and ideas for later use or for someone else to be inspired. And maybe I can even help solve a problem on the way or motivate to learn something new! Feel free to comment on any post, give feedback, suggest improvements, correct me or whatever else you think is appropriate. Cheers! - Ulysse",
            "id": "https://www.umcconnell.net/posts/2021-03-11-hello-internet/",
            "tags": ["posts"]
        }]
}